<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/theme/css/elegant.prod.9e9d5ce754.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/theme/css/custom.css" media="screen">

        <link rel="dns-prefetch" href="//fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>

        <meta name="author" content="MFIN7036 Students 2025" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="Group GPT Chatters, Blog 2, " />

<meta property="og:title" content="The Impact of Market Sentiment on Bitcoin Price Volatility and Sentiment-Based Trading Strategies (by Group &#34;GPT Chatters&#34;) "/>
<meta property="og:url" content="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/the-impact-of-market-sentiment-on-bitcoin-price-volatility-and-sentiment-based-trading-strategies-by-group-gpt-chatters.html" />
<meta property="og:description" content="By Group &#34;GPT Chatters&#34; Data Collection Our analysis is conducted based on a combination of sentiment data and market data covering a long time range. For sentiment, we collect Bitcoin-related news articles and online discussions from multiple sources. To be specific, our news data are obtained from Hugging Face and …" />
<meta property="og:site_name" content="MFIN7036 Student Blog 2025" />
<meta property="og:article:author" content="MFIN7036 Students 2025" />
<meta property="og:article:published_time" content="2026-01-21T13:21:00+08:00" />
<meta name="twitter:title" content="The Impact of Market Sentiment on Bitcoin Price Volatility and Sentiment-Based Trading Strategies (by Group &#34;GPT Chatters&#34;) ">
<meta name="twitter:description" content="By Group &#34;GPT Chatters&#34; Data Collection Our analysis is conducted based on a combination of sentiment data and market data covering a long time range. For sentiment, we collect Bitcoin-related news articles and online discussions from multiple sources. To be specific, our news data are obtained from Hugging Face and …">

        <title>The Impact of Market Sentiment on Bitcoin Price Volatility and Sentiment-Based Trading Strategies (by Group &#34;GPT Chatters&#34;)  · MFIN7036 Student Blog 2025
</title>
        <link href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="MFIN7036 Student Blog 2025 - Full Atom Feed" />



    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/"><span class=site-name>MFIN7036 Student Blog 2025</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       https://buehlmaier.github.io/MFIN7036-student-blog-2025-12
                                    >Home</a>
                                </li>
                                <li ><a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/categories.html">Categories</a></li>
                                <li ><a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/tags.html">Tags</a></li>
                                <li ><a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/the-impact-of-market-sentiment-on-bitcoin-price-volatility-and-sentiment-based-trading-strategies-by-group-gpt-chatters.html">
                The Impact of Market Sentiment on Bitcoin Price Volatility and Sentiment-Based Trading Strategies (by Group "GPT Chatters")
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <p>By Group "GPT Chatters"</p>
<h1>Data Collection</h1>
<p>Our analysis is conducted based on a combination of sentiment data and market data covering a long time range. For sentiment, we collect Bitcoin-related news articles and online discussions from multiple sources. To be specific, our news data are obtained from Hugging Face and Google News, while our Reddit comments are sourced from Kaggle. After evaluating data coverage, consistency, and practical usability, we ultimately rely on Google News articles and Reddit comments as our primary sentiment inputs. Sentiment scores are primarily constructed using FinBERT for news articles and VADER for Reddit comments. For market data, we use daily Bitcoin price data from CryptoCompare as our main source, with Yahoo Finance as a reference. These data are used to compute realized price volatility, which turns out to be our core target variable in the modeling framework.</p>
<h2>Sentiment Data - Google News</h2>
<p>To collect Bitcoin news articles from Google News, we write a function <code>get_data(coin:str = 'BTC')</code> to help us achieve the goal. It fetches daily news items (from January 2011 to the present) that contain the term "BTC". As the result, the returned document is a pandas.DataFrame containing each article’s publication time, title, and original URL, which is ideal for sentiment tracking and time-series analysis.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">coin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;BTC&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Fetch full news data from Google News RSS feed for BTC or ETH. &#39;&#39;&#39;</span>

    <span class="n">link</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span>
        <span class="s1">&#39;https://news.google.com/rss/search?q=CoinDesk+OR+Cointelegraph+OR+Decrypt,+$currency+OR+$symbol+after:$early_date+before:$late_date&amp;ceid=US:en&amp;hl=en-US&amp;gl=US&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">coin</span> <span class="o">==</span> <span class="s1">&#39;BTC&#39;</span><span class="p">:</span>
        <span class="n">currency</span> <span class="o">=</span> <span class="s1">&#39;Bitcoin&#39;</span>
    <span class="k">elif</span> <span class="n">coin</span> <span class="o">==</span> <span class="s1">&#39;ETH&#39;</span><span class="p">:</span>
        <span class="n">currency</span> <span class="o">=</span> <span class="s1">&#39;Ethereum&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Coin not supported: </span><span class="si">{</span><span class="n">coin</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">all_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">c_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;01-01-2011&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%m-%Y&#39;</span><span class="p">)</span>

    <span class="c1"># create iterator list for desired timeframe</span>
    <span class="n">iterator</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">c_date</span> <span class="o">&lt;=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">():</span>
        <span class="n">iterator</span> <span class="o">+=</span> <span class="p">[</span><span class="n">c_date</span><span class="p">]</span>
        <span class="n">c_date</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># randomly iterate over dates to avoid detection as bot     </span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
    <span class="n">total_days</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> 
                     <span class="n">total</span><span class="o">=</span><span class="n">total_days</span><span class="p">,</span> 
                     <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Fetching </span><span class="si">{</span><span class="n">coin</span><span class="si">}</span><span class="s2"> news data&quot;</span><span class="p">,</span> 
                     <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;day&quot;</span><span class="p">,</span>
                     <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}{bar}</span><span class="s2">| </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> &quot;</span>
                     <span class="s2">&quot;[</span><span class="si">{elapsed}</span><span class="s2">&lt;</span><span class="si">{remaining}</span><span class="s2">, </span><span class="si">{rate_fmt}</span><span class="s2">]&quot;</span><span class="p">):</span>

        <span class="n">next_date</span> <span class="o">=</span> <span class="n">date</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Request data from Google News</span>
        <span class="n">URL</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">currency</span><span class="o">=</span><span class="n">currency</span><span class="p">,</span>
                              <span class="n">symbol</span><span class="o">=</span><span class="n">coin</span><span class="p">,</span>
                              <span class="n">early_date</span><span class="o">=</span><span class="n">date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">),</span>
                              <span class="n">late_date</span><span class="o">=</span><span class="n">next_date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="n">request</span> <span class="o">=</span> <span class="n">GoogleNewsRSS</span><span class="p">(</span><span class="n">URL</span><span class="p">)</span>

        <span class="n">response</span> <span class="o">=</span> <span class="p">[</span><span class="n">request</span><span class="o">.</span><span class="n">publication_times</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">titles</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">urls</span><span class="p">]</span>
        <span class="n">c_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">c_data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;url&#39;</span><span class="p">]</span>
        <span class="n">c_data</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_time</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c_data</span><span class="o">.</span><span class="n">time</span><span class="p">]</span>
        <span class="n">c_data</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c_data</span><span class="o">.</span><span class="n">datetime</span><span class="p">]</span>
        <span class="n">c_data</span> <span class="o">=</span> <span class="n">c_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;timestamp&#39;</span><span class="p">)</span>

        <span class="n">all_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">all_data</span><span class="p">,</span> <span class="n">c_data</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;All elements fetched. (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">all_data</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
</code></pre></div>

<h2>Sentiment Data - Reddit Comments</h2>
<p>Considering that the comment data on Kaggle is extremely abundant, if the web-sqraping requires a significant amount of time, We use two different time-period open-source Kaggle dataset as the basic reddit comments data. The data structures of these two datasets include timestamp(seconds), subreddit, body and sentiment score. Total length of our data is more than seven million. Considering the data's accuracy, we only re-performed the text sentiment analysis on the comments themselves.</p>
<h2>Market Data - CryptoCompare</h2>
<p>We collected Bitcoin price data from two sources — Yahoo Finance and CryptoCompare. After comparing the two datasets, we decided to use the data from <a href="https://www.cryptocompare.com/">CryptoCompare</a> because it covers a longer time period. Since CryptoCompare’s API has a limit of 2000 data points per request, we use a cyclic scraping approach to retrieve the full dataset. The specific process can be seen in the main function of the scraping code, and below is the scraping code we used:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Configuration</span>
<span class="n">FSYM</span> <span class="o">=</span> <span class="s2">&quot;BTC&quot;</span>                 <span class="c1"># From symbol</span>
<span class="n">TSYM</span> <span class="o">=</span> <span class="s2">&quot;USD&quot;</span>                 <span class="c1"># To symbol</span>
<span class="n">START_DATE</span> <span class="o">=</span> <span class="s2">&quot;2011-01-01&quot;</span>    <span class="c1"># Start date (inclusive)</span>
<span class="n">LIMIT_PER_CALL</span> <span class="o">=</span> <span class="mi">2000</span>        <span class="c1"># Max days per API call</span>
<span class="n">SLEEP_SECONDS</span> <span class="o">=</span> <span class="mf">0.3</span>          <span class="c1"># Delay between requests</span>

<span class="n">HISTODAY_URL</span> <span class="o">=</span> <span class="s2">&quot;https://min-api.cryptocompare.com/data/v2/histoday&quot;</span>


<span class="k">def</span> <span class="nf">to_unix</span><span class="p">(</span><span class="n">date_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert YYYY-MM-DD string to Unix timestamp (UTC).&quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_str</span><span class="p">,</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">timestamp</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">call_histoday</span><span class="p">(</span><span class="n">to_ts</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Call CryptoCompare histoday endpoint without API key.&quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;fsym&quot;</span><span class="p">:</span> <span class="n">FSYM</span><span class="p">,</span>
        <span class="s2">&quot;tsym&quot;</span><span class="p">:</span> <span class="n">TSYM</span><span class="p">,</span>
        <span class="s2">&quot;limit&quot;</span><span class="p">:</span> <span class="n">LIMIT_PER_CALL</span><span class="p">,</span>
        <span class="s2">&quot;toTs&quot;</span><span class="p">:</span> <span class="n">to_ts</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">HISTODAY_URL</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span> <span class="o">!=</span> <span class="mi">200</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;HTTP </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">status_code</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">text</span><span class="p">[:</span><span class="mi">300</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Response&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;Error&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;API Error: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Message&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">start_ts</span> <span class="o">=</span> <span class="n">to_unix</span><span class="p">(</span><span class="n">START_DATE</span><span class="p">)</span>
    <span class="n">to_ts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span><span class="o">.</span><span class="n">timestamp</span><span class="p">())</span>

    <span class="n">all_rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">page</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Paginate backwards in time until start date</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">page</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fetching page </span><span class="si">{</span><span class="n">page</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">)</span>

        <span class="n">payload</span> <span class="o">=</span> <span class="n">call_histoday</span><span class="p">(</span><span class="n">to_ts</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Data&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Data&quot;</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rows</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">all_rows</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

        <span class="n">min_ts</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_ts</span> <span class="o">&lt;=</span> <span class="n">start_ts</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">to_ts</span> <span class="o">=</span> <span class="n">min_ts</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">SLEEP_SECONDS</span><span class="p">)</span>

    <span class="c1"># Build DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">all_rows</span><span class="p">)</span>
</code></pre></div>

<p>Then we got the Bitcoin price from 2011/01/01 to 2026/01/14. To reduce the effect of extreme changes in Bitcoin price, we used the absolute value of the daily log return of Bitcoin as the daily volatility proxy. In addition, we used winsorization (1%–99%) to deal with outliers without affecting the time series of our data. The data reprocessing code is shown below:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Ensure Date is datetime and sorted</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;Date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Date&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Date&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;Date&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Clean Close (force numeric)</span>
<span class="c1"># Convert to numeric; non-numeric becomes NaN</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;Close&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Close&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>

<span class="n">before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Close&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">after</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Close cleaned: kept </span><span class="si">{</span><span class="n">after</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">before</span><span class="si">}</span><span class="s2"> rows (dropped </span><span class="si">{</span><span class="n">before</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">after</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

<span class="c1"># Calculate daily price fluctuation metrics</span>
<span class="c1"># Directional daily price return (log return)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;Log_return&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Close&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Close&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Absolute price return (volatility proxy)</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Log_return&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

<span class="c1"># Drop first NaN (because no volatility at the first day)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Winsorize (clip) Daily_volatility_log at 1st and 99th percentiles</span>
<span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">quantile</span><span class="p">([</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">])</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">low</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="n">high</span><span class="p">)</span>

<span class="c1"># Select columns needed</span>
<span class="n">df_keep</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="s2">&quot;Close&quot;</span><span class="p">,</span> <span class="s2">&quot;Log_return&quot;</span><span class="p">,</span> <span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</code></pre></div>

<h1>NLP Sentiment Analysis</h1>
<h2>Google News - FinBert's</h2>
<h3>Model Selection</h3>
<p>Unlike Vader which works well for casual Reddit comments, FinBert's transformer architecture captures nuanced financial sentiments. This property makes it more reliably for professional news content, even though it is more computationally expensive. Therefore, considering FinBert's fine-tuned characteristics, we select to use it as the NLP sentiment assessment model for our Google News dataset. </p>
<h3>Data Cleaning and Pre-processing</h3>
<p>To satisfy FinBert's maximum 512-token limit while maximizing relevant financial context for accurate bullish/bearish scoring, we truncate overly long texts by combining the article title with the last 400 tokens in text bodies. This guarantees that elements with the strongest sentiment signals in the text, such as title, summary, and key findings, are included in text inputs. </p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">truncate_from_end</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">,</span> <span class="n">max_tokens</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_tokens</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">text</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="n">max_tokens</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">convert_tokens_to_string</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">build_finbert_text</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">clean_text</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;article_text&quot;</span><span class="p">])</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">truncate_from_end</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">,</span> <span class="n">max_tokens</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">title</span> <span class="o">+</span> <span class="s2">&quot; [SEP] &quot;</span> <span class="o">+</span> <span class="n">body</span>

<span class="n">df</span><span class="p">[</span><span class="s2">&quot;finbert_text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">progress_apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">build_finbert_text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">),</span>
    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>
</code></pre></div>

<h3>Sentiment Calculation</h3>
<p>Through calling the function <code>get_score(self, text)</code>, we can compute the final sentiment score as positive probability minus negative probability. This produces a continuous value roughly in [-1, +1] when using softmax, with positive news closer to +1 and negative news closer to -1. </p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">encoded_input</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span>
                                    <span class="n">return_tensors</span><span class="o">=</span><span class="s1">&#39;pt&#39;</span><span class="p">,</span>
                                    <span class="n">truncation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">max_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
                     <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">encoded_input</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">softmax</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># The score is the difference of the positive value and the negative</span>
    <span class="c1"># value returned by the model</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">score</span>
</code></pre></div>

<h3>Results</h3>
<p>Through FinBERT sentiment analysis, we find that 2,226 articles convey a positive (bullish) sentiment, while 1,177 articles express a negative (bearish) sentiment. This reveals an overall positive tilt in media coverage — with roughly 65.4% of the scored articles leaning bullish compared to 34.6% bearish.</p>
<h2>Reddit Comments - Vader</h2>
<h3>Model Selection</h3>
<p>Given the massive volume of over 7 million Reddit comments spanning years of Bitcoin discussions, VADER is selected because it is specifically designed for social media text: fast, lightweight, rule-based, and highly effective at handling informal language. FinBERT (or other BERT-based models), being too computationally expensive, requests too long time to handle our Reddit comments dataset with such a large volume.</p>
<h3>Data Cleaning and Pre-processing</h3>
<p>This function <code>pre_clean_vader(text)</code> is designed specifically to prepare raw Reddit comments for accurate VADER sentiment analysis. It performs the following key cleaning steps:</p>
<ul>
<li>Returns empty string for non-string or blank input  </li>
<li>Removes HTML tags using BeautifulSoup  </li>
<li>Strips special characters (keeping only letters, numbers, spaces, and basic punctuation: . , ! ? ' " -)  </li>
<li>Normalizes multiple whitespaces to single spaces  </li>
<li>Removes extra spaces before punctuation  </li>
<li>Eliminates URLs (e.g., www.example.com)  </li>
</ul>
<p>These steps ensure the text is clean, noise-free, and preserves social media features (emojis, emphasis, slang) that VADER handles well, while removing elements that could confuse scoring. The result is a lightweight, efficient pre-processing step optimized for large-scale Reddit comment sentiment aggregation in this volatility forecasting project.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">pre_clean_vader</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span> <span class="c1">#if text is str format or only whitespace</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># remove html tag</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="s1">&#39;html.parser&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span> 
    <span class="c1">#vader could identify the emoji</span>
    <span class="c1">#remove special character string</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^\w\s.,!?</span><span class="se">\&#39;</span><span class="s1">&quot;-]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="c1">#we define legal character,any character not in list will be removed</span>
    <span class="c1">#remove several whitespace/tab to single whitespace</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="c1">#remove several whitespace/tab before puncuation</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+([.,!?])&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span><span class="n">text</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;www.\w+.com&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">text</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">text</span>
</code></pre></div>

<h3>Results</h3>
<p>The Reddit daily average sentiment shows high volatility in early years (2010–2013) with extreme swings (-0.75 to +1.0), reflecting Bitcoin's speculative nature, then stabilizes mildly positive (+0.1 to +0.3) from 2014 onward, with sharp spikes during bull runs (e.g., 2017 ICO boom) and drops during crashes. Daily post count (blue bars) remained near zero until 2013, then exploded during major events with spikes aligning with sentiment extremes and realized volatility peaks, confirming Reddit as a powerful real-time indicator of retail crowd attention and emotional intensity driving Bitcoin volatility.</p>
<p><img alt="" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_image.png"></p>
<p>Additionally, we find in the sample period (2020.01 - 2022.04), only few days' average sentiment is negative. This does not mean that our statistical and sentiment analysis methods are incorrect. Rather, it is because the participants in this community are themselves holders of Bitcoin. If the market is sluggish, our overall score can indeed promptly reflect the changes in investor sentiment. For instance, from the end of 2021 to the beginning of 2022, as Bitcoin plummeted from its peak of $69,000, the VADER sentiment score showed a significant downward trend.</p>
<p><img alt="" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_image-1.png"></p>
<h1>Model Construction</h1>
<h2>Linear Regression Model</h2>
<h3>Linear Model Introduction</h3>
<p>The regression formula is shown below:</p>
<p><img alt="Linear regression formula" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_Regression_Formula.png"></p>
<p>Since we aimed to examine the different effects of positive and negative sentiment, we split the sentiment score into two parts. When the score was positive, we defined it as positive sentiment and used its value directly. When the score was negative, we defined it as negative sentiment and used its absolute value. </p>
<p>For the variable count, it is the number of news or comments, which represent the market attention for Bitcoin. We also take the logarithm of the count variable as log (1 + count) to reduce the impact of extreme values. </p>
<p>Today’s volatility is included as a lagged variable because we believe it has a strong effect on the next day’s volatility due to the volatility clustering phenomenon observed in financial markets.</p>
<p>Lagged volatility captures the persistence of market uncertainty, while attention controls for the overall level of information flow, both of which are crucial for isolating the effect of sentiment on volatility.</p>
<p>To examine the different effects of sentiment from news and social media comments, we ran two regressions: one using comments from Reddit and the other using news from Google News. During both regressions, we used VADER to score the sentiment of the text to ensure that the scoring standard is consistent. The code and result for the regression are shown below.</p>
<h3>Linear Regression for The Sentiment Scores From Reddit</h3>
<p>The code is divided into three parts. The first part is data preprocessing. In this part, we merge the sentiment data with the Bitcoin data and create two new columns: log (1 + count) and next-day volatility.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Merge by date</span>
<span class="n">df_merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">df_volatility</span><span class="p">[[</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;Log_return&quot;</span><span class="p">,</span> <span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">]],</span>
    <span class="n">df_score</span><span class="p">[[</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;vader_score&quot;</span><span class="p">,</span> <span class="s2">&quot;post_count&quot;</span><span class="p">]],</span>
    <span class="n">on</span><span class="o">=</span><span class="s2">&quot;date&quot;</span><span class="p">,</span>
    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
<span class="p">)</span>

<span class="c1"># Next-day volatility as target (t+1)</span>
<span class="c1"># shift(-1) moves tomorrow&#39;s volatility up to today&#39;s row</span>
<span class="n">df_merged</span><span class="p">[</span><span class="s2">&quot;Daily_volatility_log_t1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_merged</span><span class="p">[</span><span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Keep rows used for regression</span>
<span class="n">cols_used</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Daily_volatility_log_t1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;vader_score&quot;</span><span class="p">,</span>
    <span class="s2">&quot;post_count&quot;</span>
<span class="p">]</span>
<span class="n">df_reg</span> <span class="o">=</span> <span class="n">df_merged</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">cols_used</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Log-transform post count to reduce the impact of extreme values</span>
<span class="n">df_reg</span><span class="p">[</span><span class="s2">&quot;post_count_log&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">df_reg</span><span class="p">[</span><span class="s2">&quot;post_count&quot;</span><span class="p">])</span>

<span class="c1"># Split sentiment into positive and negative components</span>
<span class="n">df_reg</span><span class="p">[</span><span class="s2">&quot;sent_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_reg</span><span class="p">[</span><span class="s2">&quot;vader_score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">df_reg</span><span class="p">[</span><span class="s2">&quot;sent_neg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">df_reg</span><span class="p">[</span><span class="s2">&quot;vader_score&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<p>The second part is using OLS and HAC to do regression:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Regression (OLS with HAC SE)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">df_reg</span><span class="p">[</span><span class="s2">&quot;Daily_volatility_log_t1&quot;</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df_reg</span><span class="p">[[</span><span class="s2">&quot;sent_pos&quot;</span><span class="p">,</span> <span class="s2">&quot;sent_neg&quot;</span><span class="p">,</span> <span class="s2">&quot;post_count_log&quot;</span><span class="p">,</span> <span class="s2">&quot;Daily_volatility_log&quot;</span><span class="p">]]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="n">cov_type</span><span class="o">=</span><span class="s2">&quot;HAC&quot;</span><span class="p">,</span>
    <span class="n">cov_kwds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;maxlags&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
</code></pre></div>

<p>The third part is to calculate RMSE:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Simple RMSE evaluation</span>
<span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">resid</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In-sample RMSE:&quot;</span><span class="p">,</span> <span class="n">rmse</span><span class="p">)</span>

<span class="n">y_true</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">y_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

<span class="n">rmse_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean benchmark RMSE:&quot;</span><span class="p">,</span> <span class="n">rmse_mean</span><span class="p">)</span>
</code></pre></div>

<p>The regression result is shown below:</p>
<p><img alt="Regression result for Reddit" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_Regression_Result_Reddit.png"></p>
<h3>Linear Regression for the sentiment score from Google News</h3>
<p>The regression code for Google News is very similar to the previous one; therefore, we do not include it again. We only present the regression results below:</p>
<p><img alt="Regression result for Google News" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_Regression_Result_Google_News.png"></p>
<h3>Regression Results Analysis</h3>
<p>According to the results, both regression models are statistically significant and explain approximately one-tenth of the variation in Bitcoin price volatility. Although the explanatory power seems not strong, it is reasonable due to the substantial noise in financial market volatility data. </p>
<p>Regarding the relationship between the variables and volatility, the results show that the only consistently significant effect is the impact of current volatility on next-day volatility, reflecting the phenomenon of <a href="https://en.wikipedia.org/wiki/Volatility_clustering">volatility clustering</a>. This finding highlights the necessity of including lagged volatility in the regression model, as excluding it would result in biased estimates.</p>
<p>In terms of the relationship between sentiment and volatility, the results indicate that the effects differ between sentiment from comments and sentiment from news. Therefore, we believe that emotions do not simply affect volatility. The relationship between them is extremely complex and requires deeper research and analysis.</p>
<h2>Machine Learning Model - Random Forest</h2>
<h3>Why Random Forest?</h3>
<p>Firstly, there is one important question to answer before we start our discussion. Why do we choose the Random Forest for forecasting? Unlike linear models, it can capture nonlinear and interaction effects between lagged sentiment signals and Bitcoin volatility, which are likely to exist in sentiment-driven markets. Meanwhile, Random Forest acts relatively robust to noise in NLP-derived sentiment scores and is relatively stable under hyperparameter tuning. Moreover, it doesn’t impose a parametric structure on the data. All these valuable properties make Random Forest a great fit to be our first and baseline machine learning model for forecasting.</p>
<h3>Model Input</h3>
<p>The sentiment input is a daily sentiment score derived from bitcoin-related news articles sourced from Google News processed through FinBERT as well as bitcoin-related Reddit news sourced from Kaggle processed through Vader. To capture delayed market reactions, we construct multiple lagged sentiment features as model predictors. These lagged terms are <code>sentiment_lag1</code>, <code>sentiment_lag3</code>, <code>sentiment_lag7</code>, which correspond to short-term, medium-term, and weekly sentiment effects. </p>
<div class="highlight"><pre><span></span><code><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sentiment_lag1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;sentiment_score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;sentiment_lag3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;sentiment_score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;sentiment_lag7&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;sentiment_score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</code></pre></div>

<p>Lagged volatility terms are greatly autocorrelated with current volatility. So in our analysis, we avoid using lagged volatility terms as predictors as including them would allow the model to achieve good predictive performance primarily through volatility clustering rather than the effects of sentiment scores. </p>
<p>Therefore, based on the input dataset, we split our X and Y into:</p>
<div class="highlight"><pre><span></span><code><span class="n">X</span> <span class="o">=</span> <span class="n">df_model</span><span class="p">[[</span><span class="s2">&quot;sentiment_lag1&quot;</span><span class="p">,</span> <span class="s2">&quot;sentiment_lag3&quot;</span><span class="p">,</span> <span class="s2">&quot;sentiment_lag7&quot;</span><span class="p">]]</span> 
<span class="n">Y</span> <span class="o">=</span> <span class="n">df_model</span><span class="p">[</span><span class="s2">&quot;volatility&quot;</span><span class="p">]</span>
</code></pre></div>

<h3>Model Training and Hyperparameter Finetuning</h3>
<h4>Train-Test Split</h4>
<p>Instead of random sampling, the data is split chronologically. We utilize the first 80% of our data as the training dataset and the last 20% as the testing dataset. Dividing in chronological order mirrors real-world forecasting and prevents future information leakage.</p>
<div class="highlight"><pre><span></span><code><span class="n">split_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_model</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">)</span> 
<span class="n">X_train</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">split_idx</span><span class="p">]</span> 
<span class="n">Y_train</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">split_idx</span><span class="p">]</span> 
<span class="n">X_test</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">split_idx</span><span class="p">:]</span> 
<span class="n">Y_test</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">split_idx</span><span class="p">:]</span>
</code></pre></div>

<h4>Regressor Establishment</h4>
<h5>Initial Establishment</h5>
<p>Initially, to achieve higher predicting efficiency, we set the values of hyperparameters relatively high. For example, in the initial implementation below, the number of trees - ‘n_estimators’ - is set to be 800 and the maximum depth of each tree - ‘max_depth’ - is set to be 3, which are proved to be too high after finetuning.</p>
<div class="highlight"><pre><span></span><code><span class="n">initial_random_forest_model</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span> 
<span class="n">n_estimators</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span> 
<span class="n">max_depth</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> 
<span class="n">min_samples_leaf</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> 
<span class="n">random_state</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span> 
<span class="n">n_jobs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> 
<span class="n">max_features</span> <span class="o">=</span> <span class="mf">1.0</span> 
<span class="p">)</span>
</code></pre></div>

<h5>Hyperparameter Finetuning</h5>
<p>To improve generalization, hyperparameters are optimized using randomized search with time-series cross-validation. We perform cross-validation analysis on different hyperparameter sets in order to find the optimal one. </p>
<div class="highlight"><pre><span></span><code><span class="n">tscv</span> <span class="o">=</span> <span class="n">TimeSeriesSplit</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">rf</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span>
    <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span>
<span class="p">)</span>

<span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;n_estimators&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">1000</span><span class="p">],</span>
    <span class="s2">&quot;max_depth&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
    <span class="s2">&quot;min_samples_leaf&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
    <span class="s2">&quot;max_features&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;sqrt&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">random_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
    <span class="n">estimator</span><span class="o">=</span><span class="n">rf</span><span class="p">,</span>
    <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_dist</span><span class="p">,</span>
    <span class="n">n_iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>  
    <span class="n">cv</span><span class="o">=</span><span class="n">tscv</span><span class="p">,</span>
    <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_root_mean_squared_error&quot;</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>

<span class="n">random_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</code></pre></div>

<h5>Optimal Random Forest Regressor</h5>
<p>After finetuning, we've discovered the optimal hyperparameter set to construct our random forest regressor, which is:</p>
<div class="highlight"><pre><span></span><code><span class="n">optimal_random_forest_model</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span> 
<span class="n">n_estimators</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> 
<span class="n">max_depth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> 
<span class="n">min_samples_leaf</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> 
<span class="n">random_state</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span> 
<span class="n">n_jobs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> 
<span class="n">max_features</span> <span class="o">=</span> <span class="s2">&quot;sqrt&quot;</span> 
<span class="p">)</span>
</code></pre></div>

<h3>Model Evaluation</h3>
<h4>Performance Metrics</h4>
<p>Our fine-tuned random forest regressor yields a RMSE of 0.0287449, which is lower than that of linear model. This result indicates that the random forest model better captures the non-linear patterns of the relationship between the sentiment scores and price volatility.</p>
<h4>Performance Visualization</h4>
<p><img alt="" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_actual_vs_predicted.png"></p>
<p>According to the plot above, the Random Forest model learns a stable, sentiment-driven volatility baseline following the trend of volatility change. However, it systematically fails to capture sharp volatility spikes, indicating that sentiment alone explains gradual regime variation rather than extreme market shocks.</p>
<h2>Machine Learning Model - Rolling-Window XGBoost</h2>
<h3>Why Rolling-Window XGBoost?</h3>
<ul>
<li><strong>Rolling-Window</strong>: Strictly prevents look-ahead bias by retraining the model daily on a fixed recent historical period, simulates real trading, and focuses on short-term volatility clustering — essential for financial time-series forecasting.</li>
<li><strong>XGBoost</strong>: Offers superior accuracy, faster training, built-in regularization, and excellent handling of non-linear patterns and noisy data compared to alternatives like Random Forest or traditional models.</li>
</ul>
<h3>Model Input</h3>
<p>Our model is built on daily Bitcoin data, where the realized volatility serves as the target variable and the date is used to align observations chronologically. In addition to volatility, we also incorporate several auxiliary variables, including Bitcoin price, Reddit-based sentiment scores measured through Vader, Reddit post counts, and sentiment scores derived from news articles. Moreover, to capture delayed market reactions and short-term sentiment persistence, we construct multiple lagged features for both realized volatility and sentiment scores, using one-day, three-day, and seven-day lags. They are <code>realized_vol_lag1/3/7</code> and <code>vader_score_lag1/3/7</code> respectively. When enabled, a log transformation <code>np.log1p(realized_vol)</code> is applied for target and lagged terms. After generating all lagged features, observations with missing values caused by shifting are removed to ensure a clean and consistent input dataset for model training.</p>
<h3>Model Training</h3>
<ul>
<li><strong>Core Logic</strong> (<code>fit_predict</code> method):</li>
<li>For each day <code>i</code> from <code>window_size</code> to end of data:<ul>
<li><strong>Train set</strong>: Past <code>window_size</code> days (<code>df.iloc[i - window_size : i]</code>).</li>
<li><strong>Test set</strong>: Current day (<code>df.iloc[i : i+1]</code>).</li>
</ul>
</li>
<li>Train a <strong>new XGBoost model</strong> on the train set every day.</li>
<li>Predict the current day's realized volatility using the day's features.</li>
<li><strong>No future leakage</strong>: Test day data is never used in training.</li>
</ul>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">df</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;date&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The input DataFrame must contain a column named &#39;date&#39;. &quot;</span>
            <span class="s2">&quot;This column is required for sorting and recording prediction dates.&quot;</span>
        <span class="p">)</span>
        <span class="c1"># date must be datetime type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_datetime64_any_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;date&#39; column must be of datetime type. &quot;</span>
            <span class="s2">&quot;Please convert it using pd.to_datetime() or parse_dates when reading the file.&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Date must </span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;date&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)),</span>
                      <span class="n">desc</span> <span class="o">=</span> <span class="s1">&#39;Training rolling windows&#39;</span><span class="p">,</span>
                      <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;window&#39;</span><span class="p">):</span>
            <span class="n">train_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
            <span class="n">test_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">X_train</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_cols</span><span class="p">]</span>
            <span class="n">y_train</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_col</span><span class="p">]</span>

            <span class="n">X_test</span> <span class="o">=</span> <span class="n">test_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_cols</span><span class="p">]</span>
            <span class="n">y_test</span> <span class="o">=</span> <span class="n">test_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_model</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>

            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">predictions_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actuals_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dates_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">models_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">()</span> <span class="c1">#we use results function</span>
</code></pre></div>

<h3>Model Finetuning</h3>
<p>During the finetuning process, we have tried different sets of hyperparameters. After several hyperparameter adjustments, our optimal setting for the rolling-window XGBoost approach is achieved.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Value</th>
<th>Description / Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>n_estimators</code></td>
<td>800</td>
<td>Number of boosting trees (weak learners) – high count for strong ensemble power</td>
</tr>
<tr>
<td><code>max_depth</code></td>
<td>3</td>
<td>Maximum depth of each tree – shallow to prevent overfitting and keep model simple</td>
</tr>
<tr>
<td><code>learning_rate</code></td>
<td>0.05</td>
<td>Step size (shrinkage) – small value for slow, stable learning and better generalization</td>
</tr>
<tr>
<td><code>subsample</code></td>
<td>0.8</td>
<td>Fraction of training samples used per tree – 80% random subsampling reduces overfitting</td>
</tr>
<tr>
<td><code>colsample_bytree</code></td>
<td>0.8</td>
<td>Fraction of features used per tree – 80% random feature sampling adds diversity</td>
</tr>
<tr>
<td><code>random_state</code></td>
<td>42</td>
<td>Fixed random seed – ensures reproducibility across runs</td>
</tr>
<tr>
<td><code>objective</code></td>
<td>"reg:squarederror"</td>
<td>Loss function – mean squared error for regression task (volatility prediction)</td>
</tr>
</tbody>
</table>
<p>For comparison, we also defined a class that does not use the rolling window: <code>StaticXGBoostVolatility</code>.</p>
<h3>Model Evaluation</h3>
<h4>Best Model Configuration</h4>
<ul>
<li><strong>Inputs</strong>: Average VADER-score of Reddit comments + Historical Volatility (lagged features: t-1, t-3, t-7)  </li>
<li><strong>Window Size</strong>: 30 days  </li>
<li><strong>XGBoost Parameters</strong>:  </li>
<li>n_estimators: 800  </li>
<li>max_depth: 3  </li>
<li>learning_rate: 0.05  </li>
<li>subsample: 0.8  </li>
<li>colsample_bytree: 0.8  </li>
<li>random_state: 42  </li>
<li>objective: reg:squarederror </li>
</ul>
<h4>Performance Visualization</h4>
<p>As shown in this plot, the 30-day rolling-window XGBoost predictions closely follow the overall evolution of realized volatility. While the model still underestimates the magnitude of extreme volatility spikes, it consistently identifies the timing and direction of volatility rises. Compared to the performance of our best Random Forest Model, the XGBoost Model outperforms by better capturing short-term volatility dynamics and adapting to changing market regimes. XGBoost’s boosting structure enables it to learn more complex, nonlinear relationships between sentiment and volatility. Therefore, although both models struggle to some extent when it comes to predict extreme magnitudes, XGBoost provides more informative and timely volatility forecasts than the Random Forest baseline.</p>
<p><img alt="" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_image-4.png"></p>
<h4>Performance Metrics</h4>
<p>For our optimal rolling-window XGBoost, we observe a RMSE value of 0.0317 while a R-squared value of -0.187141. With a RMSE lower than that of the linear model, the optimal rolling-window XGBoost does do a better job capturing the patterns of relationship between sentiment scores and price volatility. Moreover, a negative R-squared value is reasonable as the model severely underestimate the magnitude of volatility on a few extreme days. While the direction, timing, and peak positions match well, the large absolute errors on rare high-volatility events outweigh the good fit on normal days, making the model perform worse than a simple mean prediction in terms of explained variance.</p>
<h4>Summarization</h4>
<p>Due to the existence of several extreme outliers, it is particularly challenging to predict the exact magnitude of extreme Bitcoin volatility. Nevertheless, the model demonstrates a strong ability to identify when volatility is likely to rise sharply, exhibiting good directional and timing performance even when absolute errors are large. Besides, as reflected in our SHAP analysis below, a pronounced self-correlation in volatility is revealed, which closely aligns with that discovered in previous Random Forest Model. When added together as predictors, lagged historical volatility terms exhibit dominant effects in forecasting while lagged sentiment terms only contribute limited additional predictive information. In particular, three-day sentiment measures computed within a 30-day rolling window provide meaningful signals, although their overall contribution remains secondary compared to historical volatility. Moreover, negative sentiment appears to play a more influential role than positive sentiment, as reflected by its stronger impact in the SHAP value distributions.</p>
<p><img alt="" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_image-5.png"></p>
<h2>Machine Learning Model - Insights in Trading Strategy</h2>
<p>This section records a small but important surprise we have encountered during the research process. Going in, our prior is straightforward: "Once standard technical indicators are introduced, NLP sentiment should become redundant. Technical indicators are direct functions of price and volume, while sentiment is noisy, indirect, and delayed. If anything absorbs information, it should be technicals."</p>
<h3>So Technicals Will Dominate The Sentiment? Is That Really The Case?</h3>
<p>The answer is actually <strong>no</strong>. </p>
<p>We first built a <strong>strictly symmetric pipeline</strong> for both feature families. NLP sentiment and technical indicators went through the exact same preprocessing steps: heteroskedasticity testing, unit root testing, transformations where required, identical train–CV–test splits, and the same XGBoost regression framework with the same optimization objective. This matters because it removes the most common explanation for performance gaps: inconsistent treatment.</p>
<p>Using <strong>technical indicators</strong> only, the strategy already performed well. Excess return versus buy-and-hold was around 109%, performance was stable across cross-validation folds, and the equity curve was economically interpretable. At this point, the framework was already viable on its own.</p>
<p><img alt="" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_p1.png"></p>
<p>The real surprise came when <strong>NLP sentiment was added on top of technical indicators</strong>. Excess return jumped to over 215%, more than doubling relative to the technical-only model. The improvement was not driven by a single lucky fold or regime; it appeared consistently across validation splits.</p>
<p><img alt="" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_p2.png"></p>
<p>A natural concern is that this uplift is just feature proliferation. To check this, we examined the correlation structure between NLP features and technical indicators. The result was reassuring: correlations were generally low, suggesting that sentiment contributes information that is largely orthogonal to price-based signals.</p>
<p>What ultimately convinced me was stability. Fold-level performance curves showed similar shapes and drawdown behavior, with no single period dominating returns. This makes it difficult to dismiss the result as overfitting or leakage.</p>
<p><img alt="" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/images/GPT_Chatters_02_p3.png"></p>
<p>The takeaway is simple. Technical indicators provide a strong baseline, but they do not subsume sentiment. Instead, sentiment becomes more valuable once technical structure is accounted for. One summarizes <strong>what the market has done</strong>; the other reflects <strong>how the market talks about it.</strong></p>
<p><strong>Technical indicators didn’t kill sentiment — they made its value visible.</strong></p>


             
 
            
            
            







            <hr/>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2026-01-21T13:21:00+08:00">Wed 21 January 2026</time>
            <h4>Category</h4>
            <a class="category-link" href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/categories.html#blog-2-ref">Blog 2</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/tags.html#group-gpt-chatters-ref">Group GPT Chatters
                    <span class="superscript">2</span>
</a></li>
            </ul>
<h4>Contact</h4>
<div id="sidebar-social-link">
    <a href="https://github.com/buehlmaier/MFIN7036-student-blog-2025-12" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
</div>
            





            





        </section>
</div>
</article>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-12/theme/js/elegant.prod.9e9d5ce754.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>